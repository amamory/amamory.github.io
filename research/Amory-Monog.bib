
@TECHREPORT{vagner-pep-2017,
  author       = {Vagner Macedo Martins}, 
  title        = {Ferramenta Computacional Para Predição de Alagamento na Região Hidrográfica da Redenção},
  school       = {Mestrado em Ciência da Computação - PUCRS},
  year         = 2017,
  type         = {Masters Research Proposal},
  keywords     = {LSA, flooding, advised},
  note         = {Advisor: Alexandre de Morais Amory, Co-Advisor: Regis Alexandre Lahm}, 
  url          = {https://lsa-pucrs.github.io/documentation/master_thesis/pep-doc-vagner-martins-2017.pdf}
}

@TECHREPORT{jura-tcc-2016,
     author = {Leonardo Rezende Juracy},
     title  = {Projeto de uma Célula Latch Testável},
     institution = {Faculdade de Informática, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
     year   = 2016,
     type   = {End of Term Work in Computer Engineering},
     keywords = {GAPH, design for testability, scan, advised},
     note   = {Advisor: Alexandre de Morais Amory, Co-Advisor: Matheus Trevisan Moreira},
     url    = {http://www.inf.pucrs.br/alexandre.amory/research/bib/docs/2015_TCC_Leonardo_Juracy.pdf}
}


@phdthesis{hamerski2019,
    title    = {{Support to Run-Time Adaptation by a Publish-Subscribe Based Middleware for MPSOC Architectures}},
    school   = {Escola Politécnica, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
    author   = {Hamerski, Jean},
    year     = {2019},
    address  = {Porto Alegre, Brasil},
    keywords = {GAPH, mpsoc, software},
    xxxurl_link = {http://hdl.handle.net/10923/15862},
    url_link = {http://repositorio.pucrs.br/dspace/bitstream/10923/15862/1/000495763-Texto%2bCompleto-0.pdf},
    abstract   = {Embedded applications have been migrating from single processor-based systems to intensive data communication requiring multi-processing systems. The performance demanded by applications motivate the use of Multi-Processor System-on-Chip (MPSoC) architectures. software over a complex, distributed and possibly heterogeneous hardware platform.  Run-time changes in the quality of service provided by the MPSoC platform to the applications motivate the implementation of self-adaptive MPSoC platforms. Self-adaptive MPSoC platforms employ systems composed of sensor-actuator-rich architectures that observe the changes in the execution environment and adapt the system dynamically balancing the multiple objectives across multiple architecture levels. These self-adaptive systems require communication/programming models well suited to the distributed characteristic of the environment in order to coordinate communication between the elements that compose it. This Thesis investigates current programming/communication models on MPSoC and other correlated domains regarding the coupling between the communicating elements and the adjacent hardware and software infrastructure. The hypothesis raised is that it is necessary to use a model that, besides abstracting the communication complexity, also provides a more flexible coupling between the communicating elements of the self-adaptive system. Additionally, we argue that the current approaches used to incorporate self-adaptive systems in MPSoC platforms follow a non-systematic development methodology, which impacts the quality of software related to code reuse and maintainability. Therefore, this Thesis proposes to apply the publish-subscribe model in a middleware-based development approach to perform the communication employed between the elements of a self-adaptive MPSoC platform and to improve software quality of self-adaptive systems while minimizing undesired impacts of the proposed approach on the system. The Thesis is supported through a case study where we implement a self-adaptive system following the proposed approach and compare the results with a baseline self-adaptive system according to performance, energy and software quality metrics. The results show that the proposed model employed on a middleware based development approach has improved the software quality of the self-adaptive system  by 33\% to 47.8\%, depending on the metrics evaluated, with a reduced overhead regarding metrics of performance (4.5\%) and energy spent (5.9\%). We also show that the requirements for middleware software are suitable for MPSoC platforms with memory usage constraints. }
}

@phdthesis{kuentzer2018,
    title    = {{More than a timing resilient template: a case study on reliability-oriented improvements on Blade}},
    school   = {Escola Politécnica, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
    author   = {Kuentzer, Felipe},
    year     = {2018},
    address  = {Porto Alegre, Brasil},
    keywords = {GAPH, design for testability, asynchronous, blade, advised},
    xxxurl_link = {http://tede2.pucrs.br/tede2/handle/tede/8093},
    url_link = {http://tede2.pucrs.br/tede2/bitstream/tede/8093/2/FELIPE_AUGUSTO_KUENTZER_TES.pdf},
    abstract   = {As the VLSI design moves to ultra-deep-submicron technologies timing margins added due variability in the manufacturing process, operation temperature and supply voltage become a significant part of the clock period in traditional synchronous circuits. Timing resilient architectures emerged as a promising solution to alleviate these worst-case timing margins, improving system performance while reducing energy consumption. These architectures embed additional circuits for detecting and recovering from timing violations that may arise when designing the circuit with reduced time margins. On the other hand, asynchronous systems also present potential to improve energy efficiency and performance due to the absence of a global clock. Moreover, asynchronous circuits are known to be robust to process, voltage and temperature variations. Blade is an asynchronous timing resilient template, that leverages the advantages of both asynchronous and timing resilient techniques. However, Blade still presents challenges regarding its testability, which hinders its commercial or large-scale application. Although the design for testability with scan chains is widely applied in the industry, the high silicon costs associated with its use in Blade can be prohibitive. On the other hand, asynchronous circuits can present advantages for functional testing, and the timing resilient characteristic provides constant feedback during the circuit normal operation, which can be applied for concurrent testing. In this Thesis, Blade's testability is evaluated with a different perspective, where the circuit implemented with Blade presents reliability properties that can be explored for stuck-at and delay faults testing. Initially, a fault classification method that relates behavioral patterns with structural faults inside the error detection logic and a new test-driven implementation of this detection module are proposed. The control part is analyzed for internal faults, and a new design is proposed, where the test coverage is improved and the circuit can be further optimized by the design flow. An original method for time measuring delay lines is also addressed. Finally, delay fault testing of critical paths in the data path is explored as a natural consequence of a circuit implemented with Blade, where the constant monitoring for detecting timing violations provide the necessary feedback for online detecting of these delay faults. The integration of all the contributions provides a satisfactory fault coverage for an area overload that, for the circuits evaluated in this thesis, it can vary from 4.24% to 6.87%, while the scan approach for the same circuits vary from 50.19% to 112.70%, respectively. The contributions of this Thesis demonstrated that with a few improvements in the Blade architecture it is possible to expand its reliability beyond a timing resilient system to delay violations in the data path, but also an advance for fault testing (including online faults) of the entire circuit, yield, and aging.}
}

@phdthesis{wachter2015,
    title    = {{Layered approach for runtime fault recovery in NOC-Based MPSOCS}},
    school   = {Faculdade de Informática, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
    author   = {Wachter, Eduardo Weber},
    year     = {2015},
    address  = {Porto Alegre, Brasil},
    keywords = {GAPH,MPSoC, fault tolerance, coadvised},
    xxxurl_link = {http://hdl.handle.net/10923/7538},
    url_link = {http://repositorio.pucrs.br/dspace/bitstream/10923/7538/1/000474345-Texto%2bCompleto-0.pdf},
    xxxurl_code = {https://bitbucket.org/nguyenthanhvuh/dig/},
    xxxurl_paper = {Pub/mpp.pdf},
    xxxurl_slides = {Pub/icse14_pres.pdf},
    abstract   = {Mechanisms for fault-tolerance in MPSoCs are mandatory to cope with defects during fabrication or faults during product lifetime. For instance, permanent faults on the interconnect network can stall or crash applications, even though the MPSoCs’ network has alternative faultfree paths to a given destination. Runtime Fault Tolerance provide self-organization mechanisms to continue delivering their processing services despite defective cores due to the presence of permanent and/or transient faults throughout their lifetime. This Thesis presents a runtime layered approach to a fault-tolerant MPSoC, where each layer is responsible for solving one part of the problem. The approach is built on top of a novel small specialized network used to search fault-free paths. The first layer, named physical layer, is responsible for the fault detection and fault isolation of defective routers. The second layer, named the network layer, is responsible for replacing the original faulty path by an alternative fault-free path. A fault-tolerant routing method executes a path search mechanism and reconfigures the network to use the faulty-free path. The third layer, named transport layer, implements a fault-tolerant communication protocol that triggers the path search in the network layer when a packet does not reach its destination.The last layer, application layer, is responsible for moving tasks from the defective processing element (PE) to a healthy PE, saving the task’s internal state, and restoring it in case of fault while executing a task. Results at the network layer, show a fast path finding method. The entire process of finding alternative paths takes typically less than 2000 clock cycles or 20 microseconds. In the transport layer, different approaches were evaluated being capable of detecting a lost message and start the retransmission. The results show that the overhead to retransmit the message is 2.46X compared to the time to transmit a message without fault, being all other messages transmitted with no overhead. For the DTW, MPEG, and synthetic applications the average-case application execution overhead was 0.17%, 0.09%, and 0.42%, respectively. This represents less than 5% of the application execution overhead worst case. At the application layer, the entire fault recovery protocol executes fast, with a low execution time overhead with no faults (5.67%) and with faults (17.33% - 28.34%).},
    note   = {Advisor: Fernando Gehm Moraes, Co-Advisor: Alexandre de Morais Amory}
}

@mastersthesis{juracy2018,
  author       = {Juracy, Leonardo Rezende}, 
  title        = {{Testing The Blade Resilient Asynchronous Template: A Structural Approach}},
  school       = {Escola Politécnica, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
  year         = 2018,
  address      = {Porto Alegre, Brasil},
  url_link     = {http://tede2.pucrs.br/tede2/bitstream/tede/8167/2/LEONARDO%20REZENDE%20JURACY_DIS.pdf},
  keywords     = {GAPH, design for testability, asynchronous, blade, advised},
  abstract     = {Nowadays, the synchronous circuits design approach is the most used design method since it is highly automated by commercial computer-aided design (CAD) tools. Synchronous designs incorporate timing margins to ensure the correct behavior under the worst-case scenario of process and environmental variations, limiting its clock period optimization and increasing power consumption. On one hand, asynchronous designs present some potential advantages when compared to synchronous ones, such as less power consumption and more data throughput, but they may also suffer with the process and environmental variations. On the other hand, resilient circuits techniques are an alternative to keep the design working in presence of effects of variability. Thus, Blade template has been proposed, combining  the advantages of both asynchronous and resilient circuits. The Blade template employs latches in its implementation and supports average-case circuit performance. Independently of the design style (synchronous or asynchronous), during the fabrication process of integrated circuits, some imperfections can occur, causing defects that reduce the fabrication yield. These defective ICs can present a faulty behavior, which produces an output different from the expected, and it must be identified before the circuit commercialization. Test methodologies help to find and diagnose this faulty behavior. Design for Testability (DfT) increases circuit testability by adding a degree of controllability and observability through different test techniques. Scan design is a DfT technique that provides for an external test equipment the access to the internal memory elements of a circuit, allowing test pattern insertion and response comparison. The goal of this work is to propose a fully integrated and automated structural DfT approach using commercial EDA tools and to propose a series of design methods to address the challenges related to testing asynchronous and resilient designs, with focus on Blade template. The proposed DfT flow is evaluated with a criptocore module and a microprocessor. The obtained results for the criptocore module show a fault coverage of 98.17% for stuck-at fault model and 89.37% for path-delay fault model, with an area overhead of 112.16%. The obtained results for the microprocessor show a fault coverage of 96.04% for stuck-at fault model and 99.00% for path-delay fault model, with an area overhead of 50.57%.},
  note   = {Advisor: Alexandre de Morais Amory; Co-advisor: Matheus Trevisan Moreira}
}

@mastersthesis{renan2018,
  author       = {Maidana, Renan Guedes}, 
  title        = {{Outdoor Localization System for Mobile Robots Based on Radio-Frequency Signal Strength}},
  school       = {Escola Politécnica, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
  year         = 2018,
  address      = {Porto Alegre, Brasil},
  url_link     = {http://tede2.pucrs.br/tede2/bitstream/tede/8140/2/RENAN_GUEDES_MAIDANA_DIS.pdf},
  keywords     = {LSA, robotics, localization, advised},
  abstract     = {In the field of Mobile Robotics, the localization problem consists on determining a robot's position and orientation in a three-dimensional space through sensor information. The most common solution to this problem is to employ a Global Positioning System receiver, also known as GPS, which reports absolute position in relation to an Earth-centered fixed coordinate system. However, GPS signals are greatly affected by atmospheric conditions and line-of-sight occlusion, sometimes providing very poor position estimates, if any at all. Inspired by these problems, this project proposes a localization system to be used by a robot in an uncontrolled outdoor environment, where GPS measurements are poor or unavailable. As common sensors provide inaccurate position estimates due to environmental factors (e.g. rough terrain), we propose the use of Radio-Frequency receiver-transmitter pairs, in which the Received Signal Strength Indicator is used for estimating the distances between receiver and transmitter, which in turn are used for positioning. This measurement has the advantage of being independent from lighting conditions or the state of the terrain, factors which affect other localization methods such as visual or wheel odometry. A mean positioning error of 0.41 m was achieved by fusing wheel odometry, angular velocity from a gyroscope and the received signal strength, in an Augmented Extended Kalman Filter algorithm, with an improvement of 82.66\% relative to the mean error of 2.38 m obtained with a common GPS sensor.},
  note   = {Advisor: Alexandre de Morais Amory; Co-advisor: Aurelio Tergolina Salton}
}

@mastersthesis{juliana2017,
  author       = {Oliveira, Juliana Damasio}, 
  title        = {{GoDonnie : definição e avaliação de uma linguagem de programação para comandar robô por programadores iniciantes com deficiência visual}},
  school       = {Escola Politécnica, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
  year         = 2017,
  address      = {Porto Alegre, Brasil},
  url_link     = {http://tede2.pucrs.br/tede2/bitstream/tede/7747/4/Juliana_Damasio_Oliveira_dis.pdf},
  keywords     = {LSA, robotics, assistive technology, advised},
  abstract     = {The general objective of this work was to define and evaluate a programming language to stimulate orientation and mobility (O&M) skills by people with visual impairment (VI). It is believed that by using a programming language to guide a robot in a virtual setting, the person with VI can better understand O&M skills. In this sense, it was definedthe programming language, which was called GoDonnie, and was based on the Logo language. A GoDonnie is run in a programming environment called Donnie, which provides soundbacks about running the robot. In addition, it has a 2D graphic simulator with a virtual robot, in which one can visualize the execution of the language commands, that is, the virtual robot sedeslocando in the scenario. This simulator allows the use by people with low vision, as well as serve as a resource to better visualize how the person who is blind is interacting with the robot in the environment. A GoDonnie has been evaluated to verify its usability. Evaluations were carried out which included visually impaired people and teachers of programming, without visual impairment. The results pointed out that GoDonnie has good usability, as well as helps the evelopment of O&M.},
  note   = {Advisor: Márcia de Borba Campos; Co-advisor: Alexandre de Morais Amory}
}

@mastersthesis{barreto2015,
  author       = {Barreto, Francisco Favorino da Silva}, 
  title        = {{Tolerância a falhas em elementos de processamento de MPSoCs}},
  school       = {Faculdade de Informática, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
  year         = 2015,
  address      = {Porto Alegre, Brasil},
  xxxurl_link     = {http://hdl.handle.net/10923/7743},
  url_link     = {http://repositorio.pucrs.br/dspace/bitstream/10923/7743/1/000476711-Texto%2bCompleto-0.pdf},
  keywords     = {GAPH,MPSoC, advised}, 
  abstract     = {The need of more processing capacity for embedded systems nowadays is pushing the research of MPSoCs with tens or hundreds of processors. These characteristics bring design challenges such as scalability and dependability. Such complex systems must have fault tolerant methods to ensure acceptable reliability and availability. This way, the user is not exposed to significant data losses, malfunctioning and even the total system failure. Considering this technology trend, the present work proposes a fault tolerance method with focus in fault recovery. The method uses concepts largely explored in distributed systems to solve the problem of permanent failures in the processing elements of MPSoCs. The implementation is exclusively in software, and recovers the system exposed to a permanent failure on processing elements, reallocating all tasks that were executing in the faulty element to a healthy processing element. The failed application tasks restart their executions since there is no context saving, enabling a lightweight method. The experiments are performed in the HeMPS platform, evaluating the most relevant parameters as recovery time, communication bandwidth impact, scalability and others. In the absence of faults, the proposed protocol has 21 Kbytes of memory area (20% more compared to the original kernel) and no overhead in terms of execution time. In the presence of faults, the results demonstrate total recovery times from 0.2ms to 1ms, depending on the number of reallocated tasks (1 to 7). The biggest impact in the protocol time is related with the reallocation task phase.},
  note   = {Advisor: Alexandre de Morais Amory}
}

@mastersthesis{morais2015,
  author     = {Morais, Márcio Godoy},
  title      = {{Integration of a multi-agent system into a robotic framework: a case study of a cooperative fault diagnosis application}},
  school     = {Faculdade de Informática, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
  year       = {2015},
  address    = {Porto Alegre, Brasil},
  url_link   = {http://hdl.handle.net/10923/7687},
  url_link   = {http://repositorio.pucrs.br/dspace/bitstream/10923/7687/3/000476244%20-%20Texto%20Completo.pdf},
  keywords   = {LSA,robotics, advised},
  abstract   = {Programming multi-robot autonomous systems can be extremely complex without appropriate software development techniques to abstract hardware faults, as well as can be hard to deal with the complexity of software required the coordinated autonomous behavior. Real environments are dynamic and unexpected events may occur, leading a robot to unforeseen situations or even fault situations. This work presents a method of integration of Jason multi-agent system into ROS robotic framework. Through this integration, can be easier to describe complex missions by using Jason agent language and its resources, as well as abstracting hardware details from the decision-taken process. Moreover, software modules related to the hardware control and modules which have a high CPU cost are separated from the planning and decision-taken process in software layers, allowing plan and software modules reuse in different missions and robots.Through this integration, Jason resources such as plans reconsideration and contingency plans can be used in a way where they can enable the robot to reconsider its actions and strategies in order to reach its goals or to take actions to deal with unforeseen situations due the environment unpredictability or even some robot hardware fault. The presented integration method also allows the cooperation between multiple robots through a standardized language of communication between agents. The proposed method is validated by a case study applied in real robots where a robot can detect a fault in its hardware and diagnose it through the help of another robot, in a highly abstract method of cooperative diagnosis.},
  note   = {Advisor: Alexandre de Morais Amory}
}

@mastersthesis{romani2015,
  author     = {Roman, Felipe de Fraga},
  title      = {{Fault supervision for multi robotics systems}},
  school     = {Faculdade de Informática, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
  year       = {2015},
  address    = {Porto Alegre, Brasil},
  xxxurl_link   = {http://hdl.handle.net/10923/7732},
  url_link   = {http://repositorio.pucrs.br/dspace/bitstream/10923/7732/1/000476572-Texto%2bCompleto-0.pdf},
  keywords   = {LSA,robotics, advised},
  abstract   = {As robotics becomes more common and people start to use it in routine tasks, dependability becomes more and more relevant to create trustworthy solutions. A commonly used approach to provide reliability and availability is the use of multi robots instead of a single robot. However, in case of a large teams of robots (tens or more), determining the system status can be a challenge. This work presents a runtime monitoring solution for Multi Robotic Systems. It integrates Nagios IT Monitoring tool and ROS robotic middleware. One of the potential advantages of this approach is that the use of a consolidated IT infrastructure tool enables the reuse of several relevant features developed to monitor large datacenters. Another important advantage of that this solution does not require additional software at the robot side. The experimental results demonstrate that the proposed monitoring system has a small performance impact on the robot and the monitoring server can easily support hundreds or even thousands of monitored robots.},
  note   = {Advisor: Alexandre de Morais Amory}
}

@mastersthesis{kuentzer2014,
  author     = {Kuentzer, Felipe Augusto},
  title      = {{Otimização e análise de algoritmos de ordenamento de redes proteicas}},
  school     = {Faculdade de Informática, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
  year       = {2014},
  address    = {Porto Alegre, Brasil},
  xxxurl_link   = {http://hdl.handle.net/10923/6663},
  url_link   = {http://repositorio.pucrs.br/dspace/bitstream/10923/6663/1/000458957-Texto%2bCompleto-0.pdf},
  keywords   = {bioinformatics, software optimization, seriation, advised},
  abstract   = {Analysis by Transcriptogram was developed as a solution to noise reduction, usually present in the microarray measuring technique of the Transcriptome, and has demonstrated potential to be applied as a method of disease diagnostics. The noise reduction in the measure is achived by the protein interaction network ordering, allowing gene expression analysis in whole genome scale. The Transcriptogram's efficiency to noise reduction was analyzed, however, it still lacks an analisys of the ordering quality, so that the best parameter setting for the ordering algorithm is used by the Transcriptogram. So far, this analysis is hindered by the high runtime of the ordering algorithm. In this work, an analysis of the ordering algorithm stages allows some optimizations, and consequent reduction in execution time, also allowing further analysis on which parameters settings have the greatest influence on the ordering quality. Applying the Transcriptogram to a diagnostic problem, the diagnostic measure is used to characterize the influence of the parameters of the ordering algorithm to achive better diagnoses. The results show that the protein network used in previous works doesn't produce the best diagnostics. Moreover, the ordering minimization, achieved by executing the ordering algorithm for longer periods, does not necessarily increase the probability to find better diagnosis compared to random ordering. Eventhough the experimental diagnostic results could not statistically differentiate random ordering from optimized ordering, these results cannot be considered conclusive since a single disease has been evaluated.},
  note   = {Advisor: Alexandre de Morais Amory}
}


@mastersthesis{mandelli2011,
  author     = {Mandelli, Marcelo Grandi},
  title      = {{Mapeamento dinâmico de aplicações para MPSOCS homogêneos}},
  school     = {Faculdade de Informática, {Pontifícia Universidade Católica do Rio Grande do Sul (PUCRS)}},
  year       = {2011},
  address    = {Porto Alegre, Brasil},
  xxxurl_link   = {http://hdl.handle.net/10923/1634},
  url_link   = {http://repositorio.pucrs.br/dspace/bitstream/10923/1634/1/000435006-Texto%2bCompleto-0.pdf},
  keywords   = {GAPH,MPSoC, coadvised},
  abstract   = {The advance in manufacturing technology of integrated circuits enables smaller transistors, making possible the development of SoCs (System-on-Chip). Many applications require multi-processor SoCs in order to meet their performance requirements. A SoC containing several processing elements (PEs) is called MPSoC. An MPSoC can be classified as homogeneous, when all their PEs has the same architecture; or heterogeneous, when they have different architectures. . As communication infrastructure, the MPSoC can use NoCs as a way to interconnect the PEs. NoCs may be used to replace busses, due to their advantages of higher scalability and communication parallelism.One of the main problems related to MPSoC projects is to define a PE of the system that will run each task. This problem is called task mapping. The mapping can be classified into static, which occurs at design time, and dynamic that occurs at runtime. The dynamic mapping approach requires firstly the mapping of the initial tasks of an application (which does not depend on any other task). The other tasks, in this approach, are mapped dynamically when requested. The mapping can be also classified by the number of tasks running in a PE. The mapping is classified as single task, when only one task is executed by a PE, and as multitask, when multiple tasks can be executed in a same PE.This work proposes new single task and multitask dynamic task mapping heuristics, in order to reduce communication energy. Results are evaluated using the MPSoC HeMPS, which executes application code generated from a model-based simulation environment. These heuristics are compared with mapping heuristic presented in literature, obtaining, in the evaluated scenarios, an average communication energy reduction of 9.8%, for the single task approach, and 18.6%, for the multitask approach. This work also evaluates the inclusion of dynamic load on the system, which makes necessary the implementation of an initial tasks mapping heuristic. This heuristic is an innovative contribution, since a similar approach is not found in any other work in literature.},
  note   = {Advisor: Fernando Gehm Moraes, Co-Advisor: Alexandre de Morais Amory}
}

